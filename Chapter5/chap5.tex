\section{Code Execution}
After the code is submitted, it needs to be evaluated initially and obey optional constraints using a variety of methods:

If the execution of the code itself can be sandboxed and restricted within the same Python execution environment as the game/level code, sensitive attributes can also be stored within the execution environment. However, previous attempts have deemed this impossible, as “there are too many ways to escape the untrusted namespace using the various introspection features of the Python language,” as shown by the failure of the pySandbox and many other sources (CITE THIS). Despite being risky to be in the same process as user code, checks are injected in the user python code to ensure goals are met. This is because checks are still needed to ensure that the code has been processed a certain defined way in some levels. There are also other attempts to sandbox Python code within the same execution environments. There are also tools that try to remedy this problem, RestrictedPython is a tool that defines a subset of Python language to provide input into our python environment. It gives strict bytecode access to the user code and restricts what is allowed to do but requires intimate knowledge of how Python works. 

\subsection{code transpilation for server-side execution}
Source-to-source compilers, also known as transcompiler, transpiler or cross-compilers is a set of tools that take the source code developed in a high-level programming language (source language), and after a transpilation process, it generates a translated source code written in another programming language (target language), that is syntactically equivalent. Puder et al.[4], says that cross-compilation itself provides only the tools to translate from one language to another, but to make it usable, it is necessary to offer a library to provide the building blocks and there currently exists no such libraries to transpile the python ecosystem. Additionally, some of the most prominent and performant Python to Javascript transpilers consistently have issues with blocking synchronous user input. This introduces lots of bugs and causes crashing the user's browser, which was a huge problem during testing and implementation as it was also hard to debug.

\subsection{Namespace Restrictions}
If for example, dictionaries should not be used, the keywords and methods such as {} or dict.fromkeys() can be restricted as the user’s code is run in a local namespace. This can be particularly useful in preventing “import” and removing access to parts of the runtime. 
However, this isn’t exactly foolproof as Python doesn't have strict private members like other languages such as Java or C++, allows one to walk up a class tree or access private variables such as “\_\_builtins\_\_” \cite{stackexchange_untrusted_python}. However, there is a promising project called “Restricted Python” \cite{restricted_python} currently under development that might prevent these cases in the future. 
\subsection{Code Evaluation, Validation, and Sanitization}
Code validation should be run before the code is executed, the code shall be parsed as a string to an evaluation controller to ensure the submitted code complies with the application's security policies and usage constraints. The evaluation controller also analyzes the code for potential threats, inefficiencies, or policy violations.
The validation controller should perform linting and syntax checking. It should also implement static code checking to avoid infinite loops and dangerous built-ins such as access to the OS. After that, a test runner should try to execute code but with limited time, memory, or CPU constraints.




\section{Conclusion}
Researching Python-based execution environments is a research directive that warrants more attention as the trend of educational games continues, such as Google’s Blockly \cite{google_blockly} and China’s Yuanfudao's Homework Help \cite{xiaoyuan_kousuan}.
The future steps of continuing to research Python-based execution environments are to look at key considerations such as the performance of both methods, what makes them secure, and possible alternative implementation methods. I also need to elaborate and clear up the process workflow such as detection/validation, cleaning/sanitization, submission, and evaluation phase. Lastly, I would also need to iterate on the design for modularity and scalability. The goal is to ensure a safe and secure working environment for what is needed to run such a service.