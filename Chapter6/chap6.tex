\section{Code Execution}
After the code is submitted, it needs to be evaluated initially and obey optional constraints using a variety of methods:

If the execution of the code itself can be sandboxed and restricted within the same Python execution environment as the game/level code, sensitive attributes can also be stored within the execution environment. However, previous attempts have deemed this impossible, as “there are too many ways to escape the untrusted namespace using the various introspection features of the Python language,” as shown by the failure of the pySandbox and many other sources (CITE THIS). Despite being risky to be in the same process as user code, checks are injected in the user python code to ensure goals are met. This is because checks are still needed to ensure that the code has been processed a certain defined way in some levels. There are also other attempts to sandbox Python code within the same execution environments. There are also tools that try to remedy this problem, RestrictedPython is a tool that defines a subset of Python language to provide input into our python environment. It gives strict bytecode access to the user code and restricts what is allowed to do but requires intimate knowledge of how Python works. 


\subsection{Namespace Restrictions}
If for example, dictionaries should not be used, the keywords and methods such as {} or dict.fromkeys() can be restricted as the user’s code is run in a local namespace. This can be particularly useful in preventing “import” and removing access to parts of the runtime. 
However, this isn’t exactly foolproof as Python doesn't have strict private members like other languages such as Java or C++, allows one to walk up a class tree or access private variables such as “\_\_builtins\_\_” \cite{stackexchange_untrusted_python}. However, there is a promising project called “Restricted Python” \cite{restricted_python} currently under development that might prevent these cases in the future. 

\subsection{Code Evaluation, Validation, and Sanitization}
Code validation should be run before the code is executed, the code shall be parsed as a string to an evaluation controller to ensure the submitted code complies with the application's security policies and usage constraints. The evaluation controller also analyzes the code for potential threats, inefficiencies, or policy violations.
The validation controller should perform linting and syntax checking. It should also implement static code checking to avoid infinite loops and dangerous built-ins such as access to the OS. After that, a test runner should try to execute code but with limited time, memory, or CPU constraints.


\section{Possible features}
\subsection{A live programming environment}
% we lint it, we parse it, we sandbox it, we rewrite it, we transpile it, we parse it again, we rewrite it more, we instrument it, we transform it into continuation-passing style so we can execute it piecemeal, we transpile it again, we send it over to a Web Worker, we jam it into our World simulation, we run it, and then we serialize the results, the control flow, the execution metrics, and any errors back to the main thread

% bret viktor

\subsection{File system access}
Emscripten has a virtual file system that allows the user to read and write files. This can be used to store user code and data.
